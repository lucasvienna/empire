use diesel::AsExpression;
use diesel::pg::Pg;
use diesel::serialize::{Output, ToSql};
use diesel::sql_types::Text;
use validator::ValidateEmail;

use crate::{ErrorKind, Result};

#[derive(AsExpression, Debug, Clone, PartialEq, Eq)]
#[diesel(sql_type = Text)]
pub struct UserEmail(String);

impl UserEmail {
	pub fn parse(s: String) -> Result<UserEmail> {
		if s.validate_email() {
			Ok(Self(s))
		} else {
			Err((ErrorKind::InvalidEmail, "Invalid email").into())
		}
	}
}

impl AsRef<str> for UserEmail {
	/// Returns a reference to the underlying string.
	///
	/// # Returns
	/// * `&str` - A reference to the email string
	fn as_ref(&self) -> &str {
		&self.0
	}
}

impl ToSql<Text, Pg> for UserEmail {
	/// Converts the email to its SQL representation.
	///
	/// # Arguments
	/// * `out` - The output buffer for the SQL serialization
	///
	/// # Returns
	/// * `diesel::serialize::Result` - The result of the SQL serialization
	fn to_sql<'a>(&'a self, out: &mut Output<'a, '_, Pg>) -> diesel::serialize::Result {
		<String as ToSql<Text, Pg>>::to_sql(&self.0, out)
	}
}

#[cfg(test)]
mod tests {
	use claims::assert_err;
	use fake::Fake;
	use fake::faker::internet::en::SafeEmail;
	use rand::SeedableRng;
	use rand::rngs::StdRng;

	use super::UserEmail;

	// Both `Clone` and `Debug` are required by `quickcheck`
	#[derive(Debug, Clone)]
	struct ValidEmailFixture(pub String);
	impl quickcheck::Arbitrary for ValidEmailFixture {
		fn arbitrary(g: &mut quickcheck::Gen) -> Self {
			// We get `quickcheck` and `fake` to interoperate via the `rand` crate.
			// We create a seed from a random `u64` generated by `quickcheck`'s `Gen`,
			// which is in turn determined by `quickcheck`'s own seed.
			// We then use this seed to create a new random number generator, which
			// we pass to `fake`'s `SafeEmail`.
			// This way we can generate a random valid email every time `quickcheck`
			// calls `arbitrary`, and the generation process is deterministic for
			// a given seed.
			let mut rng = StdRng::seed_from_u64(u64::arbitrary(g));
			let email = SafeEmail().fake_with_rng(&mut rng);
			Self(email)
		}
	}

	#[quickcheck_macros::quickcheck]
	fn valid_emails_are_parsed_successfully(valid_email: ValidEmailFixture) -> bool {
		UserEmail::parse(valid_email.0).is_ok()
	}

	#[test]
	fn empty_string_is_rejected() {
		let email = "".to_string();
		assert_err!(UserEmail::parse(email));
	}
	#[test]
	fn email_missing_at_symbol_is_rejected() {
		let email = "ursuladomain.com".to_string();
		assert_err!(UserEmail::parse(email));
	}
	#[test]
	fn email_missing_subject_is_rejected() {
		let email = "@domain.com".to_string();
		assert_err!(UserEmail::parse(email));
	}
}
